{
  "version": 3,
  "sources": ["../src/index.js", "../src/partial.js", "../src/utils.js", "../src/flag-x.js"],
  "sourcesContent": ["//! Regex.make 0.1.0 alpha; Steven Levithan; MIT License\n// Context-aware regex template strings with batteries included\n\nimport { transformForFlagX } from './flag-x.js';\nimport { PartialPattern, partial } from './partial.js';\nimport { CharClassContext, RegexContext, containsCharClassUnion, escapeV, getBreakoutChar, getEndContextForIncompletePattern, patternModsOn, rakePattern, replaceUnescaped, sandboxLoneCharClassCaret, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls } from './utils.js';\n\n/**\nTemplate tag for constructing a UnicodeSets-mode RegExp with advanced features and safe,\ncontext-aware interpolation of regexes, escaped strings, and partial patterns.\n\nCan be called in multiple ways:\n1. `` Regex.make`\u2026` `` - Regex pattern as a raw string.\n2. `` Regex.make('gis')`\u2026` `` - To specify flags.\n3. `` Regex.make.bind(RegExpSubclass)`\u2026` `` - With a `this` that specifies a different constructor.\n@param {string | TemplateStringsArray} first Flags or a template.\n@param {...any} [values] Values to fill the template holes.\n@returns {RegExp | (TemplateStringsArray, ...any) => RegExp}\n*/\nfunction make(first, ...values) {\n  // Allow binding to other constructors\n  const constructor = this instanceof Function ? this : RegExp;\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return makeFromTemplate(constructor, {flags: ''}, first, ...values);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !values.length) {\n    return makeFromTemplate.bind(null, constructor, {flags: first});\n  // Given an options object (undocumented)\n  } else if (Object.prototype.toString.call(first) === '[object Object]' && !values.length) {\n    return makeFromTemplate.bind(null, constructor, first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n\n/**\nMakes a UnicodeSets-mode RegExp from a template and values to fill the template holes.\n@param {RegExpConstructor} constructor\n@param {Object} options\n@param {TemplateStringsArray} template\n@param {...any} values\n@returns {RegExp}\n*/\nfunction makeFromTemplate(constructor, options, template, ...values) {\n  const {\n    flags = '',\n    __flag_x = true,\n  } = options;\n  if (/[vu]/.test(flags)) {\n    throw new Error('Flags v/u cannot be explicitly added since v is always enabled');\n  }\n\n  // Add implicit flag x; handled first because otherwise some regex syntax would have to be\n  // escaped for the sake of tokenizing even though it's within a comment\n  if (__flag_x) {\n    ({template, values} = transformForFlagX(template, values));\n  }\n\n  let runningContext = {};\n  let pattern = '';\n  // Intersperse template raw strings and values\n  template.raw.forEach((raw, i) => {\n    const wrapEscapedStrs = template.raw[i] || template.raw[i + 1];\n    // Sandbox `\\0` in character classes. Not needed outside classes because in other cases a\n    // following interpolated value would always be atomized\n    pattern += sandboxUnsafeNulls(raw, RegexContext.CHAR_CLASS);\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (i < template.raw.length - 1) {\n      let value = values[i];\n      const transformedValue = interpolate(value, flags, regexContext, charClassContext, wrapEscapedStrs);\n      pattern += transformedValue;\n    }\n  });\n  return new constructor(rakePattern(pattern), `v${flags}`);\n}\n\nfunction interpolate(value, flags, regexContext, charClassContext, wrapEscapedStrs) {\n  if (value instanceof RegExp && regexContext !== RegexContext.DEFAULT) {\n    throw new Error('Cannot interpolate a RegExp at this position because the syntax context does not match');\n  }\n  if (regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN || charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n    // Throw in all cases, but only *need* to handle a preceding unescaped backslash (which would\n    // break sandboxing) since other errors would be handled by the invalid generated regex syntax\n    throw new Error('Interpolation preceded by invalid incomplete token');\n  }\n  const isPartial = value instanceof PartialPattern;\n  let escapedValue;\n  if (!(value instanceof RegExp)) {\n    value = String(value);\n    if (!isPartial) {\n      escapedValue = escapeV(value, regexContext);\n    }\n    // Check within escaped values (not just partials) since possible breakout char > isn't escaped\n    const breakoutChar = getBreakoutChar(escapedValue || value, regexContext, charClassContext);\n    if (breakoutChar) {\n      throw new Error(`Unescaped stray \"${breakoutChar}\" in the interpolated value would have side effects outside it`);\n    }\n  }\n\n  if (\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    regexContext === RegexContext.GROUP_NAME ||\n    charClassContext === CharClassContext.ENCLOSED_TOKEN ||\n    charClassContext === CharClassContext.Q_TOKEN\n  ) {\n    return isPartial ? value : escapedValue;\n  } else if (regexContext === RegexContext.CHAR_CLASS) {\n    if (isPartial) {\n      const boundaryOperatorsRemoved = replaceUnescaped(value, '^-|^&&|-$|&&$', '');\n      if (boundaryOperatorsRemoved !== value) {\n        // Sandboxing so we don't change the chars outside the partial into being part of an\n        // operation they didn't initiate. Same as starting a partial with a quantifier\n        throw new Error('In character classes, a partial cannot use a range/set operator at its boundary; move the operation into the partial or the operator outside of it');\n      }\n      const sandboxedValue = sandboxLoneCharClassCaret(sandboxLoneDoublePunctuatorChar(value));\n      // Atomize via nested character class `[\u2026]` if it contains implicit or explicit union (check\n      // the unadjusted value)\n      return containsCharClassUnion(value) ? `[${sandboxedValue}]` : sandboxUnsafeNulls(sandboxedValue);\n    }\n    // Atomize via nested character class `[\u2026]` if more than one node\n    return containsCharClassUnion(escapedValue) ? `[${escapedValue}]` : escapedValue;\n  }\n  // `RegexContext.DEFAULT`\n  if (value instanceof RegExp) {\n    const transformed = transformForFlags(value, flags);\n    // Sandbox and atomize; if we used a pattern modifier it has the same effect\n    return transformed.usedModifier ? transformed.value : `(?:${transformed.value})`;\n  }\n  if (isPartial) {\n    // Sandbox and atomize\n    return `(?:${value})`;\n  }\n  // Sandbox and atomize\n  return wrapEscapedStrs ? `(?:${escapedValue})` : escapedValue;\n}\n\nfunction transformForFlags(regex, outerFlags) {\n  const modFlagsObj = {\n    i: null,\n    m: null,\n    s: null,\n  };\n  const newlines = '\\\\n\\\\r\\\\u2028\\\\u2029';\n  let value = regex.source;\n\n  if (regex.ignoreCase !== outerFlags.includes('i')) {\n    if (patternModsOn) {\n      modFlagsObj.i = regex.ignoreCase;\n    } else {\n      throw new Error('Pattern modifiers not supported, so the value of flag i on the interpolated RegExp must match the outer regex');\n    }\n  }\n  if (regex.dotAll !== outerFlags.includes('s')) {\n    if (patternModsOn) {\n      modFlagsObj.s = regex.dotAll;\n    } else {\n      value = replaceUnescaped(value, '\\\\.', (regex.dotAll ? '[^]' : `[^${newlines}]`), RegexContext.DEFAULT);\n    }\n  }\n  if (regex.multiline !== outerFlags.includes('m')) {\n    if (patternModsOn) {\n      modFlagsObj.m = regex.multiline;\n    } else {\n      value = replaceUnescaped(value, '\\\\^', (regex.multiline ? `(?<=^|[${newlines}])` : '(?<![^])'), RegexContext.DEFAULT);\n      value = replaceUnescaped(value, '\\\\$', (regex.multiline ? `(?=$|[${newlines}])` : '(?![^])'), RegexContext.DEFAULT);\n    }\n  }\n\n  if (patternModsOn) {\n    const keys = Object.keys(modFlagsObj);\n    let modifier = keys.filter(k => modFlagsObj[k] === true).join('');\n    const modOff = keys.filter(k => modFlagsObj[k] === false).join('');\n    if (modOff) {\n      modifier += `-${modOff}`;\n    }\n    if (modifier) {\n      return {\n        value: `(?${modifier}:${value})`,\n        usedModifier: true,\n      };\n    }\n  }\n  return {value};\n}\n\nconst Regex = {\n  make,\n  partial,\n};\n\nexport { make, partial };\nexport default Regex;\n", "export class PartialPattern {\n  #value;\n  constructor(pattern) {\n    this.#value = pattern;\n  }\n  toString() {\n    return String(this.#value);\n  }\n}\n\n/**\nCan be called in two ways:\n1. `Regex.partial(value)` - For strings or values coerced to strings\n2. `` Regex.partial`\u2026` `` - Shorthand for ``Regex.partial(String.raw`\u2026`)``\n@param {any} first\n@param {...any} [values] Values to fill the template holes.\n@returns {PartialPattern}\n*/\nexport function partial(first, ...values) {\n  if (Array.isArray(first?.raw)) {\n    return new PartialPattern(\n      // Intersperse template raw strings and values\n      first.raw.flatMap((raw, i) => i < first.raw.length - 1 ? [raw, values[i]] : raw).join('')\n    );\n  } else if (!values.length) {\n    return new PartialPattern(first ?? '');\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n", "export const RegexContext = {\n  DEFAULT: 'R_DEFAULT',\n  CHAR_CLASS: 'R_CHAR_CLASS',\n  GROUP_NAME: 'R_GROUP_NAME',\n  ENCLOSED_TOKEN: 'R_ENCLOSED_TOKEN',\n  INTERVAL_QUANTIFIER: 'R_INTERVAL_QUANTIFIER',\n  INVALID_INCOMPLETE_TOKEN: 'R_INVALID_INCOMPLETE_TOKEN',\n};\n\nexport const CharClassContext = {\n  DEFAULT: 'CC_DEFAULT',\n  RANGE: 'CC_RANGE',\n  ENCLOSED_TOKEN: 'CC_ENCLOSED_TOKEN',\n  Q_TOKEN: 'CC_Q_TOKEN',\n  INVALID_INCOMPLETE_TOKEN: 'CC_INVALID_INCOMPLETE_TOKEN',\n};\n\nexport const patternModsOn = (() => {\n  let supported = true;\n  try {\n    new RegExp('(?i-ms:)');\n  } catch (e) {\n    supported = false;\n  }\n  return supported;\n})();\n\nconst doublePunctuatorChars = '&!#$%*+,.:;<=>?@^`~';\n\n/**\n@param {string} str\n@param {RegexContext.DEFAULT | RegexContext.CHAR_CLASS} regexContext\n@returns {string}\n*/\nexport function escapeV(str, regexContext) {\n  if (regexContext === RegexContext.CHAR_CLASS) {\n    // Escape all double punctuators (including ^, which is special on its own in the first\n    // position) in case they're bordered by the same character in or outside of the escaped string\n    return str.replace(new RegExp(String.raw`[()\\[\\]{}|\\\\/\\-${doublePunctuatorChars}]`, 'g'), '\\\\$&');\n  }\n  return str.replace(/[()\\[\\]{}|\\\\^$*+?.]/g, '\\\\$&');\n}\n\n// Sandbox without escaping by repeating the character and escaping only the first one. The second\n// one is so that, if followed by the same symbol, the resulting double punctuator will still throw\n// as expected. Details:\n// - Only need to check the first position because, if it's part of an implicit union,\n//   interpolation handling will wrap it in nested `[\u2026]`.\n// - Can't just wrap in nested `[\u2026]` here, since the value might be used in a range.\n// - Can't add a second unescaped symbol if a lone symbol is the entire string because it might be\n//   followed by the same unescaped symbol outside an interpolation, and since it won't be wrapped,\n//   the second symbol wouldn't be sandboxed from the one following it.\nexport function sandboxLoneDoublePunctuatorChar(str) {\n  return str.replace(new RegExp(String.raw`^([${doublePunctuatorChars}])(?!\\1)`), (m, _, pos) => {\n    return `\\\\${m}${pos + 1 === str.length ? '' : m}`;\n  });\n}\n\n// Sandbox `^` if relevant, done so it can't change the meaning of the surrounding character class\n// if we happen to be at the first position. See `sandboxLoneDoublePunctuatorChar` for more details\nexport function sandboxLoneCharClassCaret(str) {\n  return str.replace(/^\\^/, '\\\\^^');\n}\n\n// Regex.make`[\\0${0}]` and Regex.make`[${Regex.partial`\\0`}0]` can't be guarded against via\n// nested `[\u2026]` sandboxing in character classes if the interpolated value doesn't contain union\n// (since it might be placed on a range boundary). So escape \\0 in character classes as \\u{0}\nexport function sandboxUnsafeNulls(str, inRegexContext) {\n  return replaceUnescaped(str, String.raw`\\\\0(?!\\d)`, '\\\\u{0}', inRegexContext);\n}\n\n// No special handling for escaped versions of the characters\nfunction getUnbalancedChar(pattern, leftChar, rightChar) {\n  let numOpen = 0;\n  for (const [m] of pattern.matchAll(new RegExp(`[${escapeV(leftChar + rightChar)}]`, 'g'))) {\n    numOpen += m === leftChar ? 1 : -1;\n    if (numOpen < 0) {\n      return rightChar;\n    }\n  }\n  if (numOpen > 0) {\n    return leftChar;\n  }\n  return '';\n}\n\n// Look for characters that would change the meaning of subsequent tokens outside an interpolated value\nexport function getBreakoutChar(pattern, regexContext, charClassContext) {\n  const escapesRemoved = pattern.replace(/\\\\./gsu, '');\n  // Trailing unescaped `\\`. Checking `escapesRemoved.includes('\\\\')` would also work\n  if (escapesRemoved.at(-1) === '\\\\') {\n    return '\\\\';\n  }\n  if (regexContext === RegexContext.DEFAULT) {\n    // Unbalanced `[` or `]` are also errors but don't breakout; they're caught by the wrapper\n    return getUnbalancedChar(escapesRemoved, '(', ')');\n  } else if (\n    regexContext === RegexContext.CHAR_CLASS &&\n    !(charClassContext === CharClassContext.ENCLOSED_TOKEN || charClassContext === CharClassContext.Q_TOKEN)\n  ) {\n    return getUnbalancedChar(escapesRemoved, '[', ']');\n  } else if (\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    charClassContext === CharClassContext.ENCLOSED_TOKEN ||\n    charClassContext === CharClassContext.Q_TOKEN\n  ) {\n    if (escapesRemoved.includes('}')) {\n      return '}';\n    }\n  } else if (regexContext === RegexContext.GROUP_NAME) {\n    if (escapesRemoved.includes('>')) {\n      return '>';\n    }\n  }\n  return '';\n}\n\n// To support flag x handling (where this regex is reused as a tokenizer, which isn't really its\n// purpose in `getEndContextForIncompletePattern`), the following tokens are added which would\n// otherwise not need special handling here:\n// - Partial token versions of `\\\\[cux]`. Without serving dual purpose for flag x, `incompleteT`\n//   would only *need* to know about trailing unescaped `\\\\`.\n// - Complete token versions of `\\\\[cux0]`.\n// - Negated character class opener `[^`.\n// - Group openings, so they can be stepped past.\n// - Double-punctuators.\nexport const contextToken = new RegExp(String.raw`\n  (?<groupN> \\(\\?< (?! [=!] ) | \\\\k< )\n| (?<enclosedT> \\\\[pPu]\\{ )\n| (?<qT> \\\\q\\{ )\n| (?<intervalQ> \\{ )\n| (?<incompleteT> \\\\ (?:\n    $\n  | c (?! [A-Za-z] )\n  | u (?! [A-Fa-f\\d]{4} ) [A-Fa-f\\d]{0,3}\n  | x (?! [A-Fa-f\\d]{2} ) [A-Fa-f\\d]?\n  )\n)\n| \\\\ (?:\n    c [A-Za-z]\n  | u [A-Fa-f\\d]{4}\n  | x [A-Fa-f\\d]{2}\n  | 0 \\d+\n)\n| \\[\\^\n| \\(\\?[:=!<]\n| (?<dp> [${doublePunctuatorChars}] ) \\k<dp>\n| --\n| \\\\ .\n| .\n`.replace(/\\s+/g, ''), 'gsu');\n\n// Accepts and returns its full state so it doesn't have to reprocess pattern parts that it's\n// already seen. Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function getEndContextForIncompletePattern(partialPattern, {\n  regexContext = RegexContext.DEFAULT,\n  charClassContext = CharClassContext.DEFAULT,\n  charClassDepth = 0,\n  lastPos = 0,\n}) {\n  contextToken.lastIndex = lastPos;\n  let match;\n  while (match = contextToken.exec(partialPattern)) {\n    const {0: m, groups: {groupN, enclosedT, qT, intervalQ, incompleteT}} = match;\n    if (m === '[' || m === '[^') {\n      charClassDepth++;\n      regexContext = RegexContext.CHAR_CLASS;\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (m === ']' && regexContext === RegexContext.CHAR_CLASS) {\n      if (charClassDepth) {\n        charClassDepth--;\n      }\n      if (!charClassDepth) {\n        regexContext = RegexContext.DEFAULT;\n      }\n      // Reset for accuracy, but it will end up being an error if there is an unclosed context\n      // (ex: `\\q{\u2026` without closing `}`) in the character class\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (regexContext === RegexContext.CHAR_CLASS) {\n      if (incompleteT) {\n        charClassContext = CharClassContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (m === '-') {\n        charClassContext = CharClassContext.RANGE;\n      } else if (enclosedT) {\n        charClassContext = CharClassContext.ENCLOSED_TOKEN;\n      } else if (qT) {\n        charClassContext = CharClassContext.Q_TOKEN;\n      } else if (\n        (m === '}' && (charClassContext === CharClassContext.ENCLOSED_TOKEN || charClassContext === CharClassContext.Q_TOKEN)) ||\n        // Don't want to continue in these contexts if we've advanced another token\n        charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN ||\n        charClassContext === CharClassContext.RANGE\n      ) {\n        charClassContext = CharClassContext.DEFAULT;\n      }\n    } else {\n      if (incompleteT) {\n        regexContext = RegexContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (groupN) {\n        regexContext = RegexContext.GROUP_NAME;\n      } else if (enclosedT) {\n        regexContext = RegexContext.ENCLOSED_TOKEN;\n      } else if (intervalQ) {\n        regexContext = RegexContext.INTERVAL_QUANTIFIER;\n      } else if (\n        (m === '>' && regexContext === RegexContext.GROUP_NAME) ||\n        (m === '}' && (regexContext === RegexContext.ENCLOSED_TOKEN || regexContext === RegexContext.INTERVAL_QUANTIFIER)) ||\n        // Don't want to continue in this context if we've advanced another token\n        regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN\n       ) {\n        regexContext = RegexContext.DEFAULT;\n      }\n    }\n  }\n  return {\n    regexContext,\n    charClassContext,\n    charClassDepth,\n    lastPos: partialPattern.length - 1,\n  };\n}\n\n/**\nReplaces tokens only when they're unescaped and in the given context.\nDoesn't skip over complete multicharacter tokens (only `\\` and folowing char) so must be used with\nknowledge of what's safe to do given regex syntax.\nAssumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} input\n@param {string} needle Search as a regex pattern, with flags `su`\n@param {string} replacement\n@param {RegexContext.DEFAULT | RegexContext.CHAR_CLASS} [inRegexContext]\n@returns {string}\n@example\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~');\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.]~]~`\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~', RegexContext.DEFAULT);\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.].]~`\n*/\nexport function replaceUnescaped(input, needle, replacement, inRegexContext) {\n  const regex = new RegExp(String.raw`(?!${needle})\\\\.|(?<found>${needle})|.`, 'gsu');\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const {0: m, groups: {found}} of input.matchAll(regex)) {\n    if (found && (!inRegexContext || (inRegexContext === RegexContext.DEFAULT) === !numCharClassesOpen)) {\n      result += replacement;\n      continue;\n    }\n\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n    result += m;\n  }\n  return result;\n}\n\nconst propertiesOfStringsNames = [\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n  'RGI_Emoji',\n].join('|');\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function containsCharClassUnion(charClassPattern) {\n  // Return `true` if contains:\n  // - Lowercase `\\p` and name is a property of strings (case sensitive).\n  // - `\\q`.\n  // - Two single-char-matching tokens in sequence.\n  // - One single-char-matching token followed immediately by unescaped `[`.\n  // - One single-char-matching token preceded immediately by unescaped `]`.\n  // Else, `false`.\n  // Ranges with `-` create a single token.\n  // Subtraction and intersection with `--` and `&&` create a single token.\n  // Supports any number of nested classes\n  const regex = new RegExp(String.raw`\n\\\\ (?:\n    c [A-Za-z]\n  | p \\{ (?<pPropOfStr> ${propertiesOfStringsNames} ) \\}\n  | [pP] \\{ [^\\}]+ \\}\n  | (?<qPropOfStr> q )\n  | u (?: [A-Fa-f\\d]{4} | \\{ [A-Fa-f\\d]+ \\} )\n  | x [A-Fa-f\\d]{2}\n  | .\n)\n| --\n| &&\n| .\n  `.replace(/\\s+/g, ''), 'gsu');\n  let hasFirst = false;\n  let lastM;\n  for (const {0: m, groups} of charClassPattern.matchAll(regex)) {\n    if (groups.pPropOfStr || groups.qPropOfStr) {\n      return true;\n    }\n    if (m === '[' && hasFirst) {\n      return true;\n    }\n    if (['-', '--', '&&'].includes(m)) {\n      hasFirst = false;\n    } else if (!['[', ']'].includes(m)) {\n      if (hasFirst || lastM === ']') {\n        return true;\n      }\n      hasFirst = true;\n    }\n    lastM = m;\n  }\n  return false;\n}\n\nexport function rakePattern(pattern) {\n  const div = String.raw`\\(\\?:\\)`;\n  pattern = replaceUnescaped(pattern, `^(?:${div})+`, '', RegexContext.DEFAULT);\n  pattern = replaceUnescaped(pattern, `(?:${div}){2,}`, '(?:)', RegexContext.DEFAULT);\n  pattern = replaceUnescaped(pattern, `${div}$`, '', RegexContext.DEFAULT);\n  return pattern;\n}\n", "import { PartialPattern, partial } from './partial.js';\nimport { CharClassContext, RegexContext, contextToken, getEndContextForIncompletePattern, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls } from './utils.js';\n\nexport function transformForFlagX(template, values) {\n  let newTemplate = {raw: []};\n  let newValues = [];\n  let runningContext = {};\n  template.raw.forEach((raw, i) => {\n    const result = process(raw, {...runningContext, lastPos: 0});\n    newTemplate.raw.push(result.transformed);\n    runningContext = result.runningContext;\n    if (i < template.raw.length - 1) {\n      const value = values[i];\n      if (value instanceof PartialPattern) {\n        const result = process(value, {...runningContext, lastPos: 0});\n        newValues.push(partial(result.transformed));\n        runningContext = result.runningContext;\n      } else {\n        newValues.push(value);\n      }\n    }\n  });\n  return {\n    template: newTemplate,\n    values: newValues,\n  };\n}\n\nconst divIf = cond => cond ? '(?:)' : '';\nconst ws = /^\\s$/;\nconst escapedWsOrHash = /^\\\\[\\s#]$/;\nconst charClassWs = /^[ \\t]$/;\nconst escapedCharClassWs = /^\\\\[ \\t]$/;\n\nfunction process(value, runningContext) {\n  value = String(value);\n  let ignoringWs = false;\n  let ignoringCharClassWs = false;\n  let ignoringComment = false;\n  let pattern = '';\n  let transformed = '';\n  let lastSignificantCharClassContext = '';\n  let divNeeded = false;\n  const update = (str, {noPrefix = false, postfix = ''} = {}) => {\n    str = divIf(divNeeded && !noPrefix) + str + postfix;\n    divNeeded = false;\n    return str;\n  };\n  for (const [m] of value.matchAll(contextToken)) {\n    if (ignoringComment) {\n      if (m === '\\n') {\n        ignoringComment = false;\n        divNeeded = true;\n      }\n      continue;\n    }\n    if (ignoringWs) {\n      if (ws.test(m)) {\n        continue;\n      }\n      ignoringWs = false;\n      divNeeded = true;\n    } else if (ignoringCharClassWs) {\n      if (charClassWs.test(m)) {\n        continue;\n      }\n      ignoringCharClassWs = false;\n    }\n\n    pattern += m;\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (m === '-' && regexContext === RegexContext.CHAR_CLASS && lastSignificantCharClassContext === CharClassContext.RANGE) {\n      // Need to handle this here since the main regex-parsing code would think the hyphen forms\n      // part of a subtraction operator since we've removed preceding ws\n      throw new Error('Invalid unescaped hyphen as the end value for a range');\n    }\n    if ((regexContext === RegexContext.DEFAULT && /^[?*+]\\??$/.test(m)) || (regexContext === RegexContext.INTERVAL_QUANTIFIER && m === '{')) {\n      // Skip the separator prefix and connect the quantifier to the previous token. Add a\n      // separator postfix if `m` is `?` to sandbox it from follwing tokens since `?` can be a\n      // group-type marker. Ex: `( ?:)` becomes `(?(?:):)` and throws. The loop we're in matches\n      // valid group openings in one step, so we won't arrive here if matching e.g. `(?:`\n      transformed += update(m, {noPrefix: true, postfix: divIf(m === '?')});\n    } else if (regexContext === RegexContext.DEFAULT) {\n      if (ws.test(m)) {\n        ignoringWs = true;\n      } else if (m.startsWith('#')) {\n        ignoringComment = true;\n      } else if (escapedWsOrHash.test(m)) {\n        transformed += update(m[1], {noPrefix: true});\n      } else {\n        transformed += update(m);\n      }\n    } else if (regexContext === RegexContext.CHAR_CLASS && m !== '[' && m !== '[^') {\n      if (\n        charClassWs.test(m) &&\n        ( charClassContext === CharClassContext.DEFAULT ||\n          charClassContext === CharClassContext.RANGE ||\n          charClassContext === CharClassContext.Q_TOKEN\n        )\n      ) {\n        ignoringCharClassWs = true;\n      } else if (charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n        // Need to handle this here since the main regex-parsing code wouldn't know where the token\n        // ends if we removed ws after it that was followed by something that completes the token\n        throw new Error(`Invalid incomplete token in character class: ${m}`);\n      } else if (\n        escapedCharClassWs.test(m) &&\n        (charClassContext === CharClassContext.DEFAULT || charClassContext === CharClassContext.Q_TOKEN)\n      ) {\n          transformed += update(m[1], {noPrefix: true});\n      } else if (charClassContext === CharClassContext.DEFAULT) {\n          transformed += update(sandboxLoneDoublePunctuatorChar(sandboxUnsafeNulls(m)));\n      } else {\n        transformed += update(m);\n      }\n    } else {\n      transformed += update(m);\n    }\n    if (!(ignoringWs || ignoringCharClassWs || ignoringComment)) {\n      lastSignificantCharClassContext = charClassContext;\n    }\n  }\n  return {\n    transformed,\n    runningContext,\n  };\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "src_default", "make", "partial", "PartialPattern", "#value", "pattern", "partial", "first", "values", "raw", "i", "RegexContext", "CharClassContext", "patternModsOn", "supported", "doublePunctuatorChars", "escapeV", "str", "regexContext", "sandboxLoneDoublePunctuatorChar", "m", "_", "pos", "sandboxLoneCharClassCaret", "sandboxUnsafeNulls", "inRegexContext", "replaceUnescaped", "getUnbalancedChar", "pattern", "leftChar", "rightChar", "numOpen", "getBreakoutChar", "charClassContext", "escapesRemoved", "contextToken", "getEndContextForIncompletePattern", "partialPattern", "charClassDepth", "lastPos", "match", "groupN", "enclosedT", "qT", "intervalQ", "incompleteT", "input", "needle", "replacement", "regex", "numCharClassesOpen", "result", "found", "propertiesOfStringsNames", "containsCharClassUnion", "charClassPattern", "hasFirst", "lastM", "groups", "rakePattern", "div", "transformForFlagX", "template", "values", "newTemplate", "newValues", "runningContext", "raw", "i", "result", "process", "value", "PartialPattern", "partial", "divIf", "cond", "ws", "escapedWsOrHash", "charClassWs", "escapedCharClassWs", "ignoringWs", "ignoringCharClassWs", "ignoringComment", "pattern", "transformed", "lastSignificantCharClassContext", "divNeeded", "update", "str", "noPrefix", "postfix", "m", "contextToken", "getEndContextForIncompletePattern", "regexContext", "charClassContext", "RegexContext", "CharClassContext", "sandboxLoneDoublePunctuatorChar", "sandboxUnsafeNulls", "make", "first", "values", "constructor", "makeFromTemplate", "options", "template", "flags", "__flag_x", "transformForFlagX", "runningContext", "pattern", "raw", "i", "wrapEscapedStrs", "sandboxUnsafeNulls", "RegexContext", "getEndContextForIncompletePattern", "regexContext", "charClassContext", "value", "transformedValue", "interpolate", "rakePattern", "CharClassContext", "isPartial", "PartialPattern", "escapedValue", "escapeV", "breakoutChar", "getBreakoutChar", "replaceUnescaped", "sandboxedValue", "sandboxLoneCharClassCaret", "sandboxLoneDoublePunctuatorChar", "containsCharClassUnion", "transformed", "transformForFlags", "regex", "outerFlags", "modFlagsObj", "newlines", "patternModsOn", "keys", "modifier", "k", "modOff", "Regex", "partial", "src_default", "Regex"]
}
