{
  "version": 3,
  "sources": ["../src/index.js", "../src/utils.js"],
  "sourcesContent": ["//! Regex.make 0.1.0 alpha; Steven Levithan; MIT License\n// Context-aware regex template strings with batteries included\n\nimport { CharClassContext, containsCharClassUnion, escapeV, getBreakoutChar, getEndContextForIncompletePattern, patternModsOn, RegexContext, replaceUnescaped, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls } from './utils.js';\n\n/**\nTemplate tag for constructing a UnicodeSets-mode RegExp with advanced features and safe,\ncontext-aware interpolation of regexes, escaped strings, and partial patterns.\n\nCan be called in multiple ways:\n1. `` Regex.make`\u2026` `` - Regex pattern as a raw string.\n2. `` Regex.make('gis')`\u2026` `` - To specify flags.\n3. `` Regex.make.bind(RegExpSubclass)`\u2026` `` - With a `this` that specifies a different constructor.\n@param {string | TemplateStringsArray} first Flags or a template.\n@param {...any} [values] Values to fill the template holes.\n@returns {RegExp | (TemplateStringsArray, ...any) => RegExp}\n*/\nfunction make(first, ...values) {\n  // Allow binding to other constructors\n  const constructor = this instanceof Function ? this : RegExp;\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return makeFromTemplate(constructor, '', first, ...values);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !values.length) {\n    return makeFromTemplate.bind(null, constructor, first ?? '');\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n\n/**\nMakes a UnicodeSets-mode RegExp from a template and values to fill the template holes.\n@param {RegExpConstructor} constructor\n@param {string} flags\n@param {TemplateStringsArray} template\n@param {...any} values\n@returns {RegExp}\n*/\nfunction makeFromTemplate(constructor, flags, template, ...values) {\n  if (/[vu]/.test(flags)) {\n    throw new Error('Flags v/u cannot be explicitly added since v is always enabled');\n  }\n  // To keep output cleaner for simple string escaping, don't start wrapping/sandboxing\n  // interpolated values until something triggers the need for it\n  let wrap = false;\n  let runningContext = {};\n  let pattern = '';\n  // Intersperse template raw strings and values\n  template.raw.forEach((raw, i) => {\n    if (raw !== '') {\n      wrap = true;\n    }\n    pattern += sandboxUnsafeNulls(raw, RegexContext.CHAR_CLASS);\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (i < template.raw.length - 1) {\n      let value = values[i];\n      if (value instanceof RegExp || value instanceof PartialPattern) {\n        wrap = true;\n      }\n      const transformedValue = interpolate(value, flags, regexContext, charClassContext, wrap);\n      pattern += transformedValue;\n    }\n  });\n  return new constructor(pattern, `v${flags}`);\n}\n\nfunction interpolate(value, flags, regexContext, charClassContext, wrap) {\n  if (value instanceof RegExp && regexContext !== RegexContext.DEFAULT) {\n    throw new Error('Cannot interpolate a RegExp at this position because the syntax context does not match');\n  }\n  if (regexContext === RegexContext.OPEN_ESCAPE || charClassContext === CharClassContext.OPEN_ESCAPE) {\n    throw new Error('Unescaped \"\\\\\" precedes interpolation and would have side effects inside it');\n  }\n  const isPartial = value instanceof PartialPattern;\n  let escapedValue;\n  if (!(value instanceof RegExp)) {\n    value = String(value);\n    if (!isPartial) {\n      escapedValue = escapeV(value, regexContext);\n    }\n    // Check within escaped values (not just partials) since possible breakout char > isn't escaped\n    const breakoutChar = getBreakoutChar(escapedValue || value, regexContext, charClassContext);\n    if (breakoutChar) {\n      throw new Error(`Unescaped stray \"${breakoutChar}\" in the interpolated value would have side effects outside it`);\n    }\n  }\n\n  if (\n    regexContext === RegexContext.GROUP_NAME ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    (regexContext === RegexContext.CHAR_CLASS &&\n      charClassContext === CharClassContext.ENCLOSED_TOKEN)\n  ) {\n    return isPartial ? value : escapedValue;\n  } else if (regexContext === RegexContext.CHAR_CLASS) {\n    // `CharClassContext.DEFAULT`\n    if (isPartial) {\n      const sandboxedValue = sandboxLoneDoublePunctuatorChar(value);\n      // Atomize via nested character class `[\u2026]` if it contains implicit or explicit union (check\n      // the unadjusted value)\n      return containsCharClassUnion(value) ? `[${sandboxedValue}]` : sandboxUnsafeNulls(sandboxedValue);\n    }\n    // Atomize via nested character class `[\u2026]` if more than one node\n    return containsCharClassUnion(escapedValue) ? `[${escapedValue}]` : escapedValue;\n  }\n  // `RegexContext.DEFAULT`\n  if (value instanceof RegExp) {\n    const transformed = transformForFlags(value, flags);\n    // Sandbox and atomize; if we used a pattern modifier it has the same effect\n    return transformed.usedModifier ? transformed.value : `(?:${transformed.value})`;\n  }\n  if (isPartial) {\n    // Sandbox and atomize\n    return `(?:${value})`;\n  }\n  // Sandbox and atomize; this is the only place checking `wrap` since it's true in all other cases\n  return wrap ? `(?:${escapedValue})` : escapedValue;\n}\n\nfunction transformForFlags(regex, outerFlags) {\n  const modFlagsObj = {\n    i: null,\n    m: null,\n    s: null,\n  };\n  const newlines = '\\\\n\\\\r\\\\u2028\\\\u2029';\n  let value = regex.source;\n\n  if (regex.ignoreCase !== outerFlags.includes('i')) {\n    if (patternModsOn) {\n      modFlagsObj.i = regex.ignoreCase;\n    } else {\n      throw new Error('Pattern modifiers not supported, so the value of flag i on the interpolated RegExp must match the outer regex');\n    }\n  }\n  if (regex.dotAll !== outerFlags.includes('s')) {\n    if (patternModsOn) {\n      modFlagsObj.s = regex.dotAll;\n    } else {\n      value = replaceUnescaped(value, '\\\\.', (regex.dotAll ? '[^]' : `[[^]--[${newlines}]]`), RegexContext.DEFAULT);\n    }\n  }\n  if (regex.multiline !== outerFlags.includes('m')) {\n    if (patternModsOn) {\n      modFlagsObj.m = regex.multiline;\n    } else {\n      value = replaceUnescaped(value, '\\\\^', (regex.multiline ? `(?<=^|[${newlines}])` : '(?<![^])'), RegexContext.DEFAULT);\n      value = replaceUnescaped(value, '\\\\$', (regex.multiline ? `(?=$|[${newlines}])` : '(?![^])'), RegexContext.DEFAULT);\n    }\n  }\n\n  if (patternModsOn) {\n    const keys = Object.keys(modFlagsObj);\n    let modifier = keys.filter(k => modFlagsObj[k] === true).join('');\n    const modOff = keys.filter(k => modFlagsObj[k] === false).join('');\n    if (modOff) {\n      modifier += `-${modOff}`;\n    }\n    if (modifier) {\n      return {\n        value: `(?${modifier}:${value})`,\n        usedModifier: true,\n      };\n    }\n  }\n  return {value};\n}\n\nclass PartialPattern {\n  #value;\n  constructor(pattern) {\n    this.#value = pattern;\n  }\n  toString() {\n    return String(this.#value);\n  }\n}\n\n/**\nCan be called in two ways:\n1. `Regex.partial(value)` - For strings or values coerced to strings\n2. `` Regex.partial`\u2026` `` - Shorthand for ``Regex.partial(String.raw`\u2026`)``\n@param {any} first\n@param {...any} [values] Values to fill the template holes.\n@returns {PartialPattern}\n*/\nfunction partial(first, ...values) {\n  if (Array.isArray(first?.raw)) {\n    return new PartialPattern(\n      // Intersperse template raw strings and values\n      first.raw.flatMap((raw, i) => i < first.raw.length - 1 ? [raw, values[i]] : raw).join('')\n    );\n  } else if (!values.length) {\n    return new PartialPattern(first ?? '');\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n\nconst Regex = {\n  make,\n  partial,\n};\n\nexport { make, partial };\nexport default Regex;\n", "export const RegexContext = {\n  DEFAULT: 'R_DEFAULT',\n  CHAR_CLASS: 'R_CHAR_CLASS',\n  GROUP_NAME: 'R_GROUP_NAME',\n  INTERVAL_QUANTIFIER: 'R_INTERVAL_QUANTIFIER',\n  ENCLOSED_TOKEN: 'R_ENCLOSED_TOKEN',\n  OPEN_ESCAPE: 'R_OPEN_ESCAPE',\n};\n\nexport const CharClassContext = {\n  DEFAULT: 'CC_DEFAULT',\n  ENCLOSED_TOKEN: 'CC_ENCLOSED_TOKEN',\n  OPEN_ESCAPE: 'CC_OPEN_ESCAPE',\n};\n\nexport const patternModsOn = (() => {\n  let supported = true;\n  try {\n    new RegExp('(?i-ms:)');\n  } catch (e) {\n    supported = false;\n  }\n  return supported;\n})();\n\nconst doublePunctuatorChars = '&!#$%*+,.:;<=>?@^`~';\n\nexport function escapeV(str, regexContext) {\n  if (regexContext === RegexContext.CHAR_CLASS) {\n    // Escape all double punctuators (including ^, which is special on its own in the first\n    // position) in case they're bordered by the same character in or outside of the escaped string\n    return str.replace(new RegExp(String.raw`[()\\[\\]{}|\\\\/\\-${doublePunctuatorChars}]`, 'g'), '\\\\$&');\n  }\n  return str.replace(/[()\\[\\]{}|\\\\^$*+?.]/g, '\\\\$&');\n}\n\nexport function sandboxLoneDoublePunctuatorChar(str) {\n  // Sandbox without escaping by repeating the character and escaping only the first one. The\n  // second one is so that, if followed by the same symbol, the double punctuator will still throw\n  // as expected. Can't just wrap in nested `[\u2026]` since it might be used in a range. Only need to\n  // check the first position because, if it's part of an implicit union, interpolation handling\n  // will wrap it in nested `[\u2026]`. Can't add a second unescaped symbol if a lone symbol is the\n  // entire string because then it won't be wrapped and it might be followed by the same unescaped\n  // symbol outside the interpolation. This also takes care of sandboxing a leading `^` so it can't\n  // change the meaning of the surrounding character class if we happen to be at the first position\n  return str.replace(new RegExp(`^[${doublePunctuatorChars}]`), (m, pos) => {\n    return `\\\\${m}${pos + 1 === str.length ? '' : m}`;\n  });\n}\n\n// Regex.make`[\\0${0}]` and Regex.make`[${Regex.partial`\\0`}0]` can't be guarded against via\n// nested `[\u2026]` sandboxing in character classes if the interpolated value doesn't contain union\n// (since it might be placed on a range boundary). So escape \\0 in character classes as \\u{0}\nexport function sandboxUnsafeNulls(str, inRegexContext) {\n  return replaceUnescaped(str, String.raw`\\\\0(?!\\d)`, '\\\\u{0}', inRegexContext);\n}\n\n// Look for characters that would change the meaning of subsequent tokens outside an interpolated value\nexport function getBreakoutChar(pattern, regexContext, charClassContext) {\n  const escapesRemoved = pattern.replace(/\\\\./gsu, '');\n  // Trailing unescaped `\\`. `escapesRemoved.includes('\\\\')` would also work\n  if (escapesRemoved.at(-1) === '\\\\') {\n    return '\\\\';\n  }\n  if (regexContext === RegexContext.DEFAULT) {\n    if (escapesRemoved.includes(')')) {\n      return ')';\n    }\n  }\n  if (regexContext === RegexContext.CHAR_CLASS && charClassContext === CharClassContext.DEFAULT) {\n    // Look for unescaped `]` that is not part of a self-contained nested class\n    let numOpen = 0;\n    for (const [m] of escapesRemoved.matchAll(/[\\[\\]]/g)) {\n      numOpen += m === '[' ? 1 : -1;\n      if (numOpen < 0) {\n        return ']';\n      }\n    }\n  }\n  if (\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    charClassContext === CharClassContext.ENCLOSED_TOKEN\n  ) {\n    if (escapesRemoved.includes('}')) {\n      return '}';\n    }\n  }\n  if (regexContext === RegexContext.GROUP_NAME) {\n    if (escapesRemoved.includes('>')) {\n      return '>';\n    }\n  }\n  return '';\n}\n\n// Accepts and returns its full state so it doesn't have to reprocess pattern parts that it's\n// already seen. Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function getEndContextForIncompletePattern(partialPattern, {\n  regexContext = RegexContext.DEFAULT,\n  charClassContext = CharClassContext.DEFAULT,\n  charClassDepth = 0,\n  lastPos = 0,\n}) {\n  const possibleContextToken = /(?<groupN>\\(\\?<(?![=!])|\\\\k<)|(?<intervalQ>\\{)|(?<enclosedT>\\\\[pPu]\\{)|(?<ccOnlyEnclosedT>\\\\q\\{)|\\\\.|(?<openE>\\\\)|./gsu;\n  possibleContextToken.lastIndex = lastPos;\n  let match;\n  while (match = possibleContextToken.exec(partialPattern)) {\n    const {0: m, groups: {groupN, intervalQ, enclosedT, ccOnlyEnclosedT, openE}} = match;\n    if (m === '[') {\n      charClassDepth++;\n      regexContext = RegexContext.CHAR_CLASS;\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (m === ']' && regexContext === RegexContext.CHAR_CLASS) {\n      if (charClassDepth) {\n        charClassDepth--;\n      }\n      if (!charClassDepth) {\n        regexContext = RegexContext.DEFAULT;\n      }\n      // Reset for accuracy, but it will end up being an error if there is an unclosed context in\n      // the character class\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (regexContext !== RegexContext.CHAR_CLASS) {\n      if (groupN) {\n        regexContext = RegexContext.GROUP_NAME;\n      } else if (intervalQ) {\n        regexContext = RegexContext.INTERVAL_QUANTIFIER;\n      } else if (enclosedT) {\n        regexContext = RegexContext.ENCLOSED_TOKEN;\n      } else if (openE) {\n        regexContext = RegexContext.OPEN_ESCAPE;\n      } else if (\n        (m === '>' && regexContext === RegexContext.GROUP_NAME) ||\n        (m === '}' && (regexContext === RegexContext.INTERVAL_QUANTIFIER || regexContext === RegexContext.ENCLOSED_TOKEN))\n       ) {\n        regexContext = RegexContext.DEFAULT;\n      }\n    } else if (regexContext === RegexContext.CHAR_CLASS) {\n      if (enclosedT || ccOnlyEnclosedT) {\n        charClassContext = CharClassContext.ENCLOSED_TOKEN;\n      } else if (openE) {\n        charClassContext = CharClassContext.OPEN_ESCAPE;\n      } else if (m === '}' && charClassContext === CharClassContext.ENCLOSED_TOKEN) {\n        charClassContext = CharClassContext.DEFAULT;\n      }\n    }\n  }\n  return {\n    regexContext,\n    charClassContext,\n    charClassDepth,\n    lastPos: partialPattern.length - 1,\n  };\n}\n\n/**\nReplaces tokens only when they're unescaped and in the given context.\nDoesn't skip over complete multicharacter tokens (only `\\` and folowing char) so must be used with\nknowledge of what's safe to do given regex syntax.\nAssumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} input \n@param {string} needle Search as regex pattern\n@param {string} replacement \n@param {RegexContext.DEFAULT | RegexContext.CHAR_CLASS} [inRegexContext]\n@returns {string}\n@example\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~');\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.]~]~`\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~', RegexContext.DEFAULT);\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.].]~`\n*/\nexport function replaceUnescaped(input, needle, replacement, inRegexContext) {\n  const regex = new RegExp(String.raw`(?!${needle})\\\\.|(?<found>${needle})|.`, 'gsu');\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const {0: match, groups: {found}} of input.matchAll(regex)) {\n    if (found && (!inRegexContext || (inRegexContext === RegexContext.DEFAULT) === !numCharClassesOpen)) {\n      result += replacement;\n      continue;\n    }\n\n    if (match === '[') {\n      numCharClassesOpen++;\n    } else if (match === ']') {\n      numCharClassesOpen--;\n    }\n    result += match;\n  }\n  return result;\n}\n\nconst propertiesOfStringsNames = [\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n  'RGI_Emoji',\n].join('|');\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function containsCharClassUnion(charClassPattern) {\n  // Return `true` if contains:\n  // - Lowercase `\\p` and name is a property of strings (case sensitive).\n  // - `\\q`.\n  // - Two single-char-matching tokens in sequence.\n  // - One single-char-matching token followed immediately by unescaped `[`.\n  // - One single-char-matching token preceded immediately by unescaped `]`.\n  // Else, `false`.\n  // Ranges with `-` create a single token.\n  // Subtraction and intersection with `--` and `&&` create a single token.\n  // Supports any number of nested classes\n  const regex = new RegExp(String.raw`\n\\\\ (?:\n  c [A-Za-z] |\n  p \\{ (?<pPropOfStr> ${propertiesOfStringsNames} ) \\} |\n  [pP] \\{ [^\\}]+ \\} |\n  (?<qPropOfStr> q ) |\n  u (?: [A-Fa-f0-9]{4} | \\{ [\\dA-Fa-f]+ \\} ) |\n  x [A-Fa-f0-9]{2} |\n  .\n) |\n-- |\n&& |\n.\n  `.replace(/\\s+/g, ''), 'gsu');\n  let hasFirst = false;\n  let lastMatch;\n  for (const {0: match, groups} of charClassPattern.matchAll(regex)) {\n    if (groups.pPropOfStr || groups.qPropOfStr) {\n      return true;\n    }\n    if (match === '[' && hasFirst) {\n      return true;\n    }\n    if (['-', '--', '&&'].includes(match)) {\n      hasFirst = false;\n    } else if (!['[', ']'].includes(match)) {\n      if (hasFirst || lastMatch === ']') {\n        return true;\n      }\n      hasFirst = true;\n    }\n    lastMatch = match;\n  }\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "src_default", "make", "partial", "RegexContext", "CharClassContext", "patternModsOn", "supported", "doublePunctuatorChars", "escapeV", "str", "regexContext", "sandboxLoneDoublePunctuatorChar", "m", "pos", "sandboxUnsafeNulls", "inRegexContext", "replaceUnescaped", "getBreakoutChar", "pattern", "charClassContext", "escapesRemoved", "numOpen", "getEndContextForIncompletePattern", "partialPattern", "charClassDepth", "lastPos", "possibleContextToken", "match", "groupN", "intervalQ", "enclosedT", "ccOnlyEnclosedT", "openE", "input", "needle", "replacement", "regex", "numCharClassesOpen", "result", "found", "propertiesOfStringsNames", "containsCharClassUnion", "charClassPattern", "hasFirst", "lastMatch", "groups", "make", "first", "values", "constructor", "makeFromTemplate", "flags", "template", "wrap", "runningContext", "pattern", "raw", "i", "sandboxUnsafeNulls", "RegexContext", "getEndContextForIncompletePattern", "regexContext", "charClassContext", "value", "PartialPattern", "transformedValue", "interpolate", "CharClassContext", "isPartial", "escapedValue", "escapeV", "breakoutChar", "getBreakoutChar", "sandboxedValue", "sandboxLoneDoublePunctuatorChar", "containsCharClassUnion", "transformed", "transformForFlags", "regex", "outerFlags", "modFlagsObj", "newlines", "patternModsOn", "replaceUnescaped", "keys", "modifier", "k", "modOff", "#value", "partial", "Regex", "src_default", "Regex"]
}
